// Multi-Scale Turing Patterns //

/*

 ButtonA - random seed
 ButtonB - gray/color mode
 ButMenu - exit to firmware
 
 Created by JLS 2020

 */


#include "esp_partition.h"
#include "esp_ota_ops.h"
#include <M5Stack.h>

  #define SPEAKER 25
  #define WIDTH   160
  #define HEIGHT  120
  #define WFULL   320
  #define HFULL   240
  #define SCR     (WFULL*HFULL)
  #define n       (WIDTH * HEIGHT)
  
  #define max(a, b) (((a) > (b)) ? (a) : (b))
  #define min(a, b) (((a) < (b)) ? (a) : (b))

static uint16_t gray2rgb565[64] = {
    0x0000,
    0x2000,
    0x4108,
    0x6108,
    0x8210,
    0xa210,
    0xc318,
    0xe318,
    0x0421,
    0x2421,
    0x4529,
    0x6529,
    0x8631,
    0xa631,
    0xc739,
    0xe739,
    0x0842,
    0x2842,
    0x494a,
    0x694a,
    0x8a52,
    0xaa52,
    0xcb5a,
    0xeb5a,
    0x0c63,
    0x2c63,
    0x4d6b,
    0x6d6b,
    0x8e73,
    0xae73,
    0xcf7b,
    0xef7b,
    0x1084,
    0x3084,
    0x518c,
    0x718c,
    0x9294,
    0xb294,
    0xd39c,
    0xf39c,
    0x14a5,
    0x34a5,
    0x55ad,
    0x75ad,
    0x96b5,
    0xb6b5,
    0xd7bd,
    0xf7bd,
    0x18c6,
    0x38c6,
    0x59ce,
    0x79ce,
    0x9ad6,
    0xbad6,
    0xdbde,
    0xfbde,
    0x1ce7,
    0x3ce7,
    0x5def,
    0x7def,
    0x9ef7,
    0xbef7,
    0xdfff,
    0xffff,
  };

static uint16_t color2rgb565[1024]={
0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0011, 0x0011, 0x0011, 0x0011, 0x0011, 0x0011, 0x0011, 0x0011,
0x0012, 0x0012, 0x0012, 0x0012, 0x0012, 0x0012, 0x0012, 0x0012, 0x0013, 0x0013, 0x0013, 0x0013, 0x0013, 0x0013, 0x0013, 0x0013,
0x0013, 0x0014, 0x0014, 0x0014, 0x0014, 0x0014, 0x0014, 0x0014, 0x0014, 0x0015, 0x0015, 0x0015, 0x0015, 0x0015, 0x0015, 0x0015,
0x0015, 0x0016, 0x0016, 0x0016, 0x0016, 0x0016, 0x0016, 0x0016, 0x0016, 0x0017, 0x0017, 0x0017, 0x0017, 0x0017, 0x0017, 0x0017,
0x0017, 0x0017, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0019, 0x0019, 0x0019, 0x0019, 0x0019, 0x0019,
0x0019, 0x0019, 0x001A, 0x001A, 0x001A, 0x001A, 0x001A, 0x001A, 0x001A, 0x001A, 0x001B, 0x001B, 0x001B, 0x001B, 0x001B, 0x001B,
0x001B, 0x001B, 0x001B, 0x001C, 0x001C, 0x001C, 0x001C, 0x001C, 0x001C, 0x001C, 0x001C, 0x001D, 0x001D, 0x001D, 0x001D, 0x001D,
0x001D, 0x001D, 0x001D, 0x001E, 0x001E, 0x001E, 0x001E, 0x001E, 0x001E, 0x001E, 0x001E, 0x001F, 0x001F, 0x001F, 0x001F, 0x001F,
0x001F, 0x001F, 0x003F, 0x003F, 0x003F, 0x003F, 0x005F, 0x005F, 0x005F, 0x005F, 0x007F, 0x007F, 0x007F, 0x007F, 0x009F, 0x009F,
0x009F, 0x009F, 0x00BF, 0x00BF, 0x00BF, 0x00BF, 0x00DF, 0x00DF, 0x00DF, 0x00DF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x011F, 0x011F,
0x011F, 0x011F, 0x013F, 0x013F, 0x013F, 0x013F, 0x015F, 0x015F, 0x015F, 0x015F, 0x017F, 0x017F, 0x017F, 0x017F, 0x019F, 0x019F,
0x019F, 0x019F, 0x01BF, 0x01BF, 0x01BF, 0x01BF, 0x01DF, 0x01DF, 0x01DF, 0x01DF, 0x01FF, 0x01FF, 0x01FF, 0x01FF, 0x021F, 0x021F,
0x021F, 0x021F, 0x021F, 0x023F, 0x023F, 0x023F, 0x023F, 0x025F, 0x025F, 0x025F, 0x025F, 0x027F, 0x027F, 0x027F, 0x027F, 0x029F,
0x029F, 0x029F, 0x029F, 0x02BF, 0x02BF, 0x02BF, 0x02BF, 0x02DF, 0x02DF, 0x02DF, 0x02DF, 0x02FF, 0x02FF, 0x02FF, 0x02FF, 0x031F,
0x031F, 0x031F, 0x031F, 0x033F, 0x033F, 0x033F, 0x033F, 0x035F, 0x035F, 0x035F, 0x035F, 0x037F, 0x037F, 0x037F, 0x037F, 0x039F,
0x039F, 0x039F, 0x039F, 0x03BF, 0x03BF, 0x03BF, 0x03BF, 0x03DF, 0x03DF, 0x03DF, 0x03DF, 0x03FF, 0x03FF, 0x03FF, 0x03FF, 0x041F,
0x041F, 0x041F, 0x041F, 0x041F, 0x043F, 0x043F, 0x043F, 0x043F, 0x045F, 0x045F, 0x045F, 0x045F, 0x047F, 0x047F, 0x047F, 0x047F,
0x049F, 0x049F, 0x049F, 0x049F, 0x04BF, 0x04BF, 0x04BF, 0x04BF, 0x04DF, 0x04DF, 0x04DF, 0x04DF, 0x04FF, 0x04FF, 0x04FF, 0x04FF,
0x051F, 0x051F, 0x051F, 0x051F, 0x053F, 0x053F, 0x053F, 0x053F, 0x055F, 0x055F, 0x055F, 0x055F, 0x057F, 0x057F, 0x057F, 0x057F,
0x059F, 0x059F, 0x059F, 0x059F, 0x05BF, 0x05BF, 0x05BF, 0x05BF, 0x05DF, 0x05DF, 0x05DF, 0x05DF, 0x05FF, 0x05FF, 0x05FF, 0x05FF,
0x05FF, 0x061F, 0x061F, 0x061F, 0x061F, 0x063F, 0x063F, 0x063F, 0x063F, 0x065F, 0x065F, 0x065F, 0x065F, 0x067F, 0x067F, 0x067F,
0x067F, 0x069F, 0x069F, 0x069F, 0x069F, 0x06BF, 0x06BF, 0x06BF, 0x06BF, 0x06DF, 0x06DF, 0x06DF, 0x06DF, 0x06FF, 0x06FF, 0x06FF,
0x06FF, 0x071F, 0x071F, 0x071F, 0x071F, 0x073F, 0x073F, 0x073F, 0x073F, 0x075F, 0x075F, 0x075F, 0x075F, 0x077F, 0x077F, 0x077F,
0x077F, 0x079F, 0x079F, 0x079F, 0x079F, 0x07BF, 0x07BF, 0x07BF, 0x07BF, 0x07DF, 0x07DF, 0x07DF, 0x07DF, 0x07FF, 0x07FF, 0x07FF,
0x07FF, 0x07FF, 0x07FF, 0x07FF, 0x0FFE, 0x0FFE, 0x0FFE, 0x0FFE, 0x0FFE, 0x0FFE, 0x0FFE, 0x0FFE, 0x17FD, 0x17FD, 0x17FD, 0x17FD,
0x17FD, 0x17FD, 0x17FD, 0x17FD, 0x1FFC, 0x1FFC, 0x1FFC, 0x1FFC, 0x1FFC, 0x1FFC, 0x1FFC, 0x1FFC, 0x27FB, 0x27FB, 0x27FB, 0x27FB,
0x27FB, 0x27FB, 0x27FB, 0x27FB, 0x27FB, 0x2FFA, 0x2FFA, 0x2FFA, 0x2FFA, 0x2FFA, 0x2FFA, 0x2FFA, 0x2FFA, 0x37F9, 0x37F9, 0x37F9,
0x37F9, 0x37F9, 0x37F9, 0x37F9, 0x37F9, 0x3FF8, 0x3FF8, 0x3FF8, 0x3FF8, 0x3FF8, 0x3FF8, 0x3FF8, 0x3FF8, 0x47F7, 0x47F7, 0x47F7,
0x47F7, 0x47F7, 0x47F7, 0x47F7, 0x47F7, 0x47F7, 0x4FF6, 0x4FF6, 0x4FF6, 0x4FF6, 0x4FF6, 0x4FF6, 0x4FF6, 0x4FF6, 0x57F5, 0x57F5,
0x57F5, 0x57F5, 0x57F5, 0x57F5, 0x57F5, 0x57F5, 0x5FF4, 0x5FF4, 0x5FF4, 0x5FF4, 0x5FF4, 0x5FF4, 0x5FF4, 0x5FF4, 0x67F3, 0x67F3,
0x67F3, 0x67F3, 0x67F3, 0x67F3, 0x67F3, 0x67F3, 0x67F3, 0x6FF2, 0x6FF2, 0x6FF2, 0x6FF2, 0x6FF2, 0x6FF2, 0x6FF2, 0x6FF2, 0x77F1,
0x77F1, 0x77F1, 0x77F1, 0x77F1, 0x77F1, 0x77F1, 0x77F1, 0x7FF0, 0x7FF0, 0x7FF0, 0x7FF0, 0x7FF0, 0x7FF0, 0x7FF0, 0x7FF0, 0x87F0,
0x87EF, 0x87EF, 0x87EF, 0x87EF, 0x87EF, 0x87EF, 0x87EF, 0x87EF, 0x8FEE, 0x8FEE, 0x8FEE, 0x8FEE, 0x8FEE, 0x8FEE, 0x8FEE, 0x8FEE,
0x97ED, 0x97ED, 0x97ED, 0x97ED, 0x97ED, 0x97ED, 0x97ED, 0x97ED, 0x9FEC, 0x9FEC, 0x9FEC, 0x9FEC, 0x9FEC, 0x9FEC, 0x9FEC, 0x9FEC,
0x9FEC, 0xA7EB, 0xA7EB, 0xA7EB, 0xA7EB, 0xA7EB, 0xA7EB, 0xA7EB, 0xA7EB, 0xAFEA, 0xAFEA, 0xAFEA, 0xAFEA, 0xAFEA, 0xAFEA, 0xAFEA,
0xAFEA, 0xB7E9, 0xB7E9, 0xB7E9, 0xB7E9, 0xB7E9, 0xB7E9, 0xB7E9, 0xB7E9, 0xBFE8, 0xBFE8, 0xBFE8, 0xBFE8, 0xBFE8, 0xBFE8, 0xBFE8,
0xBFE8, 0xBFE8, 0xC7E7, 0xC7E7, 0xC7E7, 0xC7E7, 0xC7E7, 0xC7E7, 0xC7E7, 0xC7E7, 0xCFE6, 0xCFE6, 0xCFE6, 0xCFE6, 0xCFE6, 0xCFE6,
0xCFE6, 0xCFE6, 0xD7E5, 0xD7E5, 0xD7E5, 0xD7E5, 0xD7E5, 0xD7E5, 0xD7E5, 0xD7E5, 0xDFE4, 0xDFE4, 0xDFE4, 0xDFE4, 0xDFE4, 0xDFE4,
0xDFE4, 0xDFE4, 0xDFE4, 0xE7E3, 0xE7E3, 0xE7E3, 0xE7E3, 0xE7E3, 0xE7E3, 0xE7E3, 0xE7E3, 0xEFE2, 0xEFE2, 0xEFE2, 0xEFE2, 0xEFE2,
0xEFE2, 0xEFE2, 0xEFE2, 0xF7E1, 0xF7E1, 0xF7E1, 0xF7E1, 0xF7E1, 0xF7E1, 0xF7E1, 0xF7E1, 0xFFE0, 0xFFE0, 0xFFE0, 0xFFE0, 0xFFE0,
0xFFE0, 0xFFE0, 0xFFC0, 0xFFC0, 0xFFC0, 0xFFC0, 0xFFA0, 0xFFA0, 0xFFA0, 0xFFA0, 0xFF80, 0xFF80, 0xFF80, 0xFF80, 0xFF60, 0xFF60,
0xFF60, 0xFF60, 0xFF40, 0xFF40, 0xFF40, 0xFF40, 0xFF20, 0xFF20, 0xFF20, 0xFF20, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFEE0, 0xFEE0,
0xFEE0, 0xFEE0, 0xFEC0, 0xFEC0, 0xFEC0, 0xFEC0, 0xFEA0, 0xFEA0, 0xFEA0, 0xFEA0, 0xFE80, 0xFE80, 0xFE80, 0xFE80, 0xFE60, 0xFE60,
0xFE60, 0xFE60, 0xFE40, 0xFE40, 0xFE40, 0xFE40, 0xFE20, 0xFE20, 0xFE20, 0xFE20, 0xFE00, 0xFE00, 0xFE00, 0xFE00, 0xFDE0, 0xFDE0,
0xFDE0, 0xFDE0, 0xFDE0, 0xFDC0, 0xFDC0, 0xFDC0, 0xFDC0, 0xFDA0, 0xFDA0, 0xFDA0, 0xFDA0, 0xFD80, 0xFD80, 0xFD80, 0xFD80, 0xFD60,
0xFD60, 0xFD60, 0xFD60, 0xFD40, 0xFD40, 0xFD40, 0xFD40, 0xFD20, 0xFD20, 0xFD20, 0xFD20, 0xFD00, 0xFD00, 0xFD00, 0xFD00, 0xFCE0,
0xFCE0, 0xFCE0, 0xFCE0, 0xFCC0, 0xFCC0, 0xFCC0, 0xFCC0, 0xFCA0, 0xFCA0, 0xFCA0, 0xFCA0, 0xFC80, 0xFC80, 0xFC80, 0xFC80, 0xFC60,
0xFC60, 0xFC60, 0xFC60, 0xFC40, 0xFC40, 0xFC40, 0xFC40, 0xFC20, 0xFC20, 0xFC20, 0xFC20, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
0xFBE0, 0xFBE0, 0xFBE0, 0xFBE0, 0xFBC0, 0xFBC0, 0xFBC0, 0xFBC0, 0xFBA0, 0xFBA0, 0xFBA0, 0xFBA0, 0xFB80, 0xFB80, 0xFB80, 0xFB80,
0xFB60, 0xFB60, 0xFB60, 0xFB60, 0xFB40, 0xFB40, 0xFB40, 0xFB40, 0xFB20, 0xFB20, 0xFB20, 0xFB20, 0xFB00, 0xFB00, 0xFB00, 0xFB00,
0xFAE0, 0xFAE0, 0xFAE0, 0xFAE0, 0xFAC0, 0xFAC0, 0xFAC0, 0xFAC0, 0xFAA0, 0xFAA0, 0xFAA0, 0xFAA0, 0xFA80, 0xFA80, 0xFA80, 0xFA80,
0xFA60, 0xFA60, 0xFA60, 0xFA60, 0xFA40, 0xFA40, 0xFA40, 0xFA40, 0xFA20, 0xFA20, 0xFA20, 0xFA20, 0xFA00, 0xFA00, 0xFA00, 0xFA00,
0xFA00, 0xF9E0, 0xF9E0, 0xF9E0, 0xF9E0, 0xF9C0, 0xF9C0, 0xF9C0, 0xF9C0, 0xF9A0, 0xF9A0, 0xF9A0, 0xF9A0, 0xF980, 0xF980, 0xF980,
0xF980, 0xF960, 0xF960, 0xF960, 0xF960, 0xF940, 0xF940, 0xF940, 0xF940, 0xF920, 0xF920, 0xF920, 0xF920, 0xF900, 0xF900, 0xF900,
0xF900, 0xF8E0, 0xF8E0, 0xF8E0, 0xF8E0, 0xF8C0, 0xF8C0, 0xF8C0, 0xF8C0, 0xF8A0, 0xF8A0, 0xF8A0, 0xF8A0, 0xF880, 0xF880, 0xF880,
0xF880, 0xF860, 0xF860, 0xF860, 0xF860, 0xF840, 0xF840, 0xF840, 0xF840, 0xF820, 0xF820, 0xF820, 0xF820, 0xF800, 0xF800, 0xF800,
0xF800, 0xF800, 0xF800, 0xF800, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xF000, 0xE800, 0xE800, 0xE800, 0xE800,
0xE800, 0xE800, 0xE800, 0xE800, 0xE000, 0xE000, 0xE000, 0xE000, 0xE000, 0xE000, 0xE000, 0xE000, 0xD800, 0xD800, 0xD800, 0xD800,
0xD800, 0xD800, 0xD800, 0xD800, 0xD800, 0xD000, 0xD000, 0xD000, 0xD000, 0xD000, 0xD000, 0xD000, 0xD000, 0xC800, 0xC800, 0xC800,
0xC800, 0xC800, 0xC800, 0xC800, 0xC800, 0xC000, 0xC000, 0xC000, 0xC000, 0xC000, 0xC000, 0xC000, 0xC000, 0xB800, 0xB800, 0xB800,
0xB800, 0xB800, 0xB800, 0xB800, 0xB800, 0xB800, 0xB000, 0xB000, 0xB000, 0xB000, 0xB000, 0xB000, 0xB000, 0xB000, 0xA800, 0xA800,
0xA800, 0xA800, 0xA800, 0xA800, 0xA800, 0xA800, 0xA000, 0xA000, 0xA000, 0xA000, 0xA000, 0xA000, 0xA000, 0xA000, 0x9800, 0x9800,
0x9800, 0x9800, 0x9800, 0x9800, 0x9800, 0x9800, 0x9800, 0x9000, 0x9000, 0x9000, 0x9000, 0x9000, 0x9000, 0x9000, 0x9000, 0x8800,
0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x8800, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000
};

  uint32_t size = ((2*WIDTH) * (2*HEIGHT));

  float sinus[7] = { 0, sinf(TWO_PI/1.0f), sinf(TWO_PI/2.0f),  sinf(TWO_PI/3.0f),  sinf(TWO_PI/4.0f),  sinf(TWO_PI/5.0f),  sinf(TWO_PI/6.0f) };
  float cosinus[7] = { 0, cosf(TWO_PI/1.0f), cosf(TWO_PI/2.0f),  cosf(TWO_PI/3.0f),  cosf(TWO_PI/4.0f),  cosf(TWO_PI/5.0f),  cosf(TWO_PI/6.0f) };

  uint16_t *col = NULL;

  uint16_t coll;
  bool colen = false;
  
  int8_t *bestLevel = NULL;
  float *grid = NULL;
  float *blurBuffer = NULL;
  float *variation = NULL;
  float *bestVariation = NULL;
  float *activator = NULL;
  float *inhibitor = NULL;
  float *swap = NULL;
  bool *direction = NULL;
  float *stepSizes = NULL;
  float *colorShift = NULL;
  int8_t *radii = NULL;

  float randomf(float minf, float maxf) {return minf + (esp_random()%(1UL << 31)) * (maxf - minf) / (1UL << 31);}

  int level, i, x, y;
  int blurlevels, symmetry;
 
  float base;
  int levels;
  float stepScale;
  float stepOffset;
  float blurFactor;

  
void setup() {

  srand(time(NULL));

  M5.begin();
  pinMode(SPEAKER, OUTPUT);
  digitalWrite(SPEAKER, LOW);
  M5.Lcd.setTextColor(TFT_WHITE, TFT_BLACK);
  M5.lcd.fillScreen(TFT_BLACK);

  bestLevel = (int8_t*)ps_malloc(size);
  grid = (float*)ps_malloc(size);
  colorShift = (float*)ps_malloc(WIDTH);
  blurBuffer = (float*)ps_malloc(size);
  variation = (float*)ps_malloc(size);
  bestVariation = (float*)ps_malloc(size);
  activator = (float*)ps_malloc(size);
  inhibitor = (float*)ps_malloc(size);
  swap = (float*)ps_malloc(size);
  direction = (bool*)ps_malloc(size);
  stepSizes = (float*)ps_malloc(WIDTH);
  radii = (int8_t*)ps_malloc(WIDTH);
  col = (uint16_t*)ps_malloc(4*(SCR));

  rndrule();
  
}


void loop() {

  if (M5.BtnA.wasPressed()) { rndrule(); M5.Lcd.drawString("RND", 10, 10, 2); }
  if (M5.BtnB.wasPressed()) { colen = !colen; M5.Lcd.drawString("COLOR", 10, 10, 2); }
  if (M5.BtnC.wasPressed()) {
    const esp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);
    esp_ota_set_boot_partition(partition);
    esp_restart();
  }

  if(symmetry >= 1) for(i = 0; i < n; i++) grid[i] = grid[i] * 0.9f + grid[getSymmetry(i, WIDTH, HEIGHT)] * 0.1f;

  memcpy(activator, grid, 4*n);
 
  for (level = 0; level < levels - 1; level++) {
      
    int radius = radii[level];
    
    if(level <= blurlevels){       
      for (y = 0; y < HEIGHT; y++) {
        for (x = 0; x < WIDTH; x++) {
          int t = y * WIDTH + x;
          if (y == 0 && x == 0) blurBuffer[t] = activator[t];
          else if (y == 0) blurBuffer[t] = blurBuffer[t - 1] + activator[t];
          else if (x == 0) blurBuffer[t] = blurBuffer[t - WIDTH] + activator[t];
          else blurBuffer[t] = blurBuffer[t - 1] + blurBuffer[t - WIDTH] - blurBuffer[t - WIDTH - 1] + activator[t];
        }
      }
    }

    for (y = 0; y < HEIGHT; y++) {
      for (x = 0; x < WIDTH; x++) {
        int minx = max(0, x - radius);
        int maxx = min(x + radius, WIDTH - 1);
        int miny = max(0, y - radius);
        int maxy = min(y + radius, HEIGHT - 1);
        int area = (maxx - minx) * (maxy - miny);
       
        int nw = miny * WIDTH + minx;
        int ne = miny * WIDTH + maxx;
        int sw = maxy * WIDTH + minx;
        int se = maxy * WIDTH + maxx;
       
        int t = y * WIDTH + x;
        inhibitor[t] = (blurBuffer[se] - blurBuffer[sw] - blurBuffer[ne] + blurBuffer[nw]) / area;
      }
    }
    
    for (i = 0; i < n; i++) {
      float variation = fabs(activator[i] - inhibitor[i]);
      if (level == 0 || variation < bestVariation[i]) {
        bestVariation[i] = variation;
        bestLevel[i] = level;
        direction[i] = activator[i] > inhibitor[i];
      }
    }
 
   if(level==0) {
      memcpy(activator, inhibitor, 4*n);
    } else {
      memcpy(swap, activator, 4*n);
      memcpy(activator, inhibitor, 4*n);
      memcpy(inhibitor, swap, 4*n);
    }
            
  } 

  float smallest = MAXFLOAT;
  float largest = -MAXFLOAT;

  for (i = 0; i < n; i++) {
    float curStep = stepSizes[bestLevel[i]];
    if (direction[i]) {
      if (colen) grid[i] += curStep * colorShift[bestLevel[i]];
      else grid[i] += curStep;
    }
    else {
      if (colen) grid[i] -= curStep * colorShift[bestLevel[i]];
      else grid[i] -= curStep;
    }
    smallest = min(smallest, grid[i]);
    largest = max(largest, grid[i]);
  }

  float range = (largest - smallest) / 2.0f;

  for (y = 0; y < HEIGHT; y++) {
    for (x = 0; x < WIDTH; x++) {     
      grid[x+WIDTH*y] = ((grid[x+WIDTH*y] - smallest) / range) - 1.0f;
      if (colen) {
        coll = 512 + (512 * grid[x+WIDTH*y]);
        col[(2*x)+(2*y)*WFULL] = color2rgb565[coll];
      } else {
        coll = 128 + (128 * grid[x+WIDTH*y]);
        col[(2*x)+(2*y)*WFULL] = gray2rgb565[(uint8_t)coll>>2];
      }
    }
  }

  M5.lcd.pushRect(0, 0, WFULL, HFULL,(uint16_t *) col);
  M5.update();

}

void rndrule(){

  memset((uint16_t *) col, 0, 4*SCR);

  symmetry = esp_random()%7;
  base = randomf(1.5f, 2.4f);
  stepScale = randomf(0.01f, 0.2f);
  stepOffset = randomf(0.01f, 0.4f);
  blurFactor = randomf(0.5f, 1.0f);
  
  levels = (int) (logf(max(WIDTH,HEIGHT)) / logf(base)) - 1.0f;
  blurlevels = (int) max(0, (levels+1) * blurFactor - 0.5f);

  for (i = 0; i < levels; i++) {
    int radius = (int)powf(base, i);
    radii[i] = radius;
    stepSizes[i] = logf(radius) * stepScale + stepOffset;
    colorShift[i] = logf(radius) * (levels-i);
  }

  for (i = 0; i < n; i++) grid[i] = randomf(-1.0f, 1.0f);

}

int getSymmetry(int i, int w, int h) {
  
  if(symmetry <= 1) return i;
  if(symmetry == 2) return n - 1 - i;
  int x1 = i % w;
  int y1 = i / w;
  float dx = x1 - w/2.0f;
  float dy = y1 - h/2.0f;
  int x2 = w/2 + (int)(dx * cosinus[symmetry] + dy * sinus[symmetry]);
  int y2 = h/2 + (int)(dx * -sinus[symmetry] + dy * cosinus[symmetry]);
  int j = x2 + y2 * w;
  return j<0 ? j+n : j>=n ? j-n : j;
  
}
